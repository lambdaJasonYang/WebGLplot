import{mat4 as t}from'gl-matrix';var e;(t=>{t[t.POINTS=0]='POINTS',t[t.LINES=1]='LINES',t[t.LINE_LOOP=2]='LINE_LOOP',t[t.LINE_STRIP=3]='LINE_STRIP',t[t.TRIANGLES=4]='TRIANGLES',t[t.TRIANGLE_STRIP=5]='TRIANGLE_STRIP',t[t.TRIANGLE_FAN=6]='TRIANGLE_FAN'})(e||(e={}));let r=-1;const o=t=>t.filter((t=>t!=1/0&&t!=-1/0)),a=(t,e,a=30,i=30,n=.1)=>{const c=((t,e,r)=>{const o=[];for(let a=t;a<e;a+=r)o.push(a);return o})(a,i,n),s=c.map(e),l=((t,e)=>{const a=o(t),i=o(e),n=2/Math.max(...a),c=2/Math.max(...i),s=[];for(let r=0;r<t.length;r++)s[2*r]=t[r]*n,s[2*r+1]=e[r]*c;return r=t.length,s})(c,s),m=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,m),t.bufferData(t.ARRAY_BUFFER,new Float32Array(l),t.STATIC_DRAW),{position:m}},i=(t,e,r)=>{const o=t.createShader(e);return t.shaderSource(o,r),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)?o:(alert('An error occurred compiling the shaders: '+t.getShaderInfoLog(o)),t.deleteShader(o),null)},n=(o,n,c=-30,s=30,l=.1,m=e.POINTS,L=400,P=400)=>{o.width=L,o.height=P;const h=o.getContext('webgl2'),T=((t,e,r)=>{const o=i(t,t.VERTEX_SHADER,e),a=i(t,t.FRAGMENT_SHADER,r),n=t.createProgram();return t.attachShader(n,o),t.attachShader(n,a),t.linkProgram(n),t.getProgramParameter(n,t.LINK_STATUS)?n:(alert('Unable to initialize the shader program: '+t.getProgramInfoLog(n)),null)})(h,'\n  attribute vec4 aVertexPosition;\n  uniform mat4 uModelViewMatrix;\n  uniform mat4 uProjectionMatrix;\n  void main() {\n      gl_PointSize = 1.0;\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n  }','\n  void main() {\n      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  }'),g={program:T,attribLocations:{vertexPosition:h.getAttribLocation(T,'aVertexPosition')},uniformLocations:{projectionMatrix:h.getUniformLocation(T,'uProjectionMatrix'),modelViewMatrix:h.getUniformLocation(T,'uModelViewMatrix')}};((e,o,a,i,n=e.LINE_STRIP)=>{e.clearColor(0,0,0,1),e.clearDepth(1),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const c=45*Math.PI/180;if(!(e.canvas instanceof HTMLCanvasElement))throw new TypeError(`canvas with type ${typeof e.canvas} cannot extract height width`);const s=e.canvas,l=s.clientWidth/s.clientHeight,m=t.create();t.perspective(m,c,l,.1,100);const L=t.create();t.translate(L,L,[-0,0,-6]),t.rotate(L,L,i,[0,0,1]);{const t=2,r=e.FLOAT,i=!1,n=0,c=0;e.bindBuffer(e.ARRAY_BUFFER,a.position),e.vertexAttribPointer(o.attribLocations.vertexPosition,t,r,i,n,c),e.enableVertexAttribArray(o.attribLocations.vertexPosition)}e.useProgram(o.program),e.uniformMatrix4fv(o.uniformLocations.projectionMatrix,!1,m),e.uniformMatrix4fv(o.uniformLocations.modelViewMatrix,!1,L),e.drawArrays(n,0,r)})(h,g,a(h,n,c,s,l),0,m)};export{e as DrawModeGL,n as buildPlotWebGL};
